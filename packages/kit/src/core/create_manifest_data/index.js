import fs from 'fs';
import path from 'path';
import mime from 'mime';
import { posixify } from '../utils.js';
import { mkdirp } from '../filesystem/index.js';

/** @typedef {{
 *   content: string;
 *   dynamic: boolean;
 *   spread: boolean;
 * }} Part */

/** @typedef {{
 *   basename: string;
 *   ext: string;
 *   parts: Part[],
 *   file: string;
 *   is_dir: boolean;
 *   is_index: boolean;
 *   is_page: boolean;
 *   route_suffix: string
 * }} Item */

/** @typedef {import('types/i18n').Translations} Translations */

/**
 * @param {{
 *   config: import('types/config').ValidatedConfig;
 *   output: string;
 *   cwd?: string;
 * }} opts
 * @returns {import('types/internal').ManifestData}
 */
export default function create_manifest_data({ config, output, cwd = process.cwd() }) {
	/**
	 * @param {string} file_name
	 * @param {string} dir
	 */
	function find_layout(file_name, dir) {
		const files = config.extensions.map((ext) => posixify(path.join(dir, `${file_name}${ext}`)));
		return files.find((file) => fs.existsSync(path.resolve(cwd, file)));
	}

	/**
	 * @param {string} file_name
	 * @param {string} dir
	 */
	function find_translations(file_name, dir) {
		const localesDir = path.resolve(cwd, posixify(file_name ? path.join(dir, file_name) : dir));
		const files = fs.existsSync(localesDir)
			? fs
					.readdirSync(localesDir)
					.map((basename) => {
						const resolved = path.join(localesDir, basename);
						const file = posixify(path.relative(cwd, resolved));
						return file;
					})
					.filter((file) => path.extname(file) === '.json')
			: [];

		if (files.length === 0) return undefined;

		/** @type {Translations} */
		const init = {};

		return files.reduce((translations, file) => {
			const locale = path.basename(file).slice(0, -5);
			translations[locale] = JSON.parse(fs.readFileSync(path.resolve(cwd, file), 'utf-8'));
			return translations;
		}, init);
	}

	/**
	 * @param {any} value
	 * @return {value is Translations}
	 */
	const isTranslations = (value) => value && typeof value === 'object';

	/**
	 * @param {any} value
	 * @return {Translations}
	 */
	const toTranslations = (value) => (isTranslations(value) ? value : {});

	/**
	 * @param {Translations} translations
	 * @returns {string}
	 */
	function compile_translations(translations) {
		/** @param {string} value */
		function processValue(value) {
			const params = [
				...new Set([...value.matchAll(/(^|[^$])\$(\d+)/g)].map((match) => parseInt(match[2])))
			].sort((a, b) => a - b);

			if (params.length > 0) {
				const inputParams = `(${params.map((p) => `$${p}`).join(', ')})`;

				/** @type {Record<number, {param: string, options: string[]}>} */
				const plurals = {};
				let pluralIndex = Math.max(...params) + 1;

				const pluralValue = value.replace(/{{PLURAL:(\$\d+)\|([^}]+)}}/g, (g1, g2, g3) => {
					plurals[pluralIndex] = {
						param: g2,
						options: g3.split('|').map(
							/**
							 * @param {string} c
							 * @param {number} index
							 */
							(c, index) => {
								if (index === 0) return `1: "${c}"`;
								if (index === 1) return `_: "${c}"`;
								const [count, text] = c.split('=');
								return `${count}: "${text}"`;
							}
						)
					};
					params.push(pluralIndex);
					return `$${pluralIndex++}`;
				});

				const pluralVars = Object.entries(plurals)
					.map(
						([index, { param, options }]) =>
							`const v${index} = { ${options.join(
								', '
							)} }; const $${index} = v${index}[${param}] || v${index}._; `
					)
					.join('');

				return `${inputParams} => { ${pluralVars}return "${pluralValue}"${params
					.sort((a, b) => b - a)
					.map((p) => `.replace(/(^|[^$])\\$${p}(?!\\d])/g, \`$1\${$${p}}\`)`)
					.join('')} }`;
			}

			return `"${value}"`;
		}

		return `{\n\t\t\t${Object.entries(translations)
			.map(
				([key, value]) =>
					`"${key}": ${
						typeof value === 'object'
							? compile_translations(value).replace(/\n/gm, '\n\t')
							: processValue(value)
					}`
			)
			.join(',\n\t\t\t')}
		}`.trim();
	}

	/**
	 * @param {import('types/i18n').I18nLocale} locale
	 * @param {Translations} translations
	 */
	function create_locale_component(locale, translations) {
		const dir = `${output}/components/locales`;
		const file = `${dir}/${locale.code}.svelte`;
		const code = `
		<!-- This file is generated by @sveltejs/kit — do not edit it! -->
		<script context="module">
			/**
			 * @type {import('@sveltejs/kit').Load}
			 */
			export async function load({ page, fetch, session, context }) {
				return { 
					context: { 
						...context,
						i18n: {
							locale: ${JSON.stringify(locale)},
							defaultLocale: ${config.kit.i18n ? JSON.stringify(config.kit.i18n.defaultLocale) : 'undefined'},
							locales: [${config.kit.i18n.locales.map((locale) => JSON.stringify(locale)).join(', ')}]
						}
					}
				};
			}
		</script>

		<script>
			import { getContext, setContext } from 'svelte';

			const i18n = getContext('__svelte_i18n__');
			i18n.update((i18n) => ({
				...i18n, 
				locale: ${JSON.stringify(locale)},
				translations: ${compile_translations(translations).replace(/\n/gm, '\n\t\t')}
			}));
		</script>

		<slot></slot>
		`
			.replace(/^\t\t/gm, '')
			.trim();

		mkdirp(path.dirname(file));
		fs.writeFileSync(file, code);

		return path.relative(cwd, file);
	}

	/**
	 * @param {string} filename
	 * @param {{locale: string, pattern: RegExp}[]} patterns
	 */
	function create_pattern_component(filename, patterns) {
		const dir = `${output}/components/locales`;
		const file = `${dir}/${filename}`;

		const code = `
		<!-- This file is generated by @sveltejs/kit — do not edit it! -->
		<script context="module">
			const patterns = [${patterns
				.map(({ locale, pattern }) => `{ locale: "${locale}", pattern: ${pattern} }`)
				.join(', ')}];

			function pathFromPattern(pattern, params) {
				let index = 0;
				return pattern.source
					.slice(1, -1)
					.replace(/\\\\\\//g, '/')
					.replace(/\\(\\[\\^\\/\\]\\+\\?\\)/g, () => params[index++])
					.replace(/\\/\\?$/, '');
			}

			/**
			 * @type {import('@sveltejs/kit').Load}
			 */
			export async function load({ page, fetch, session, context }) {
				const pattern = patterns.find((p) => p.locale === context.i18n.locale.code)?.pattern;
				if (pattern) {
					const [_, ...params] = page.path.match(pattern);
					const localizedPaths = patterns.reduce((paths, { locale, pattern }) => {
						paths[locale] = pathFromPattern(pattern, params);
						return paths;
					}, {});
					return {
						context: {
							...context,
							i18n: {
								...context.i18n,
								localizedPaths
							}
						},
						props: {
							localizedPaths
						}
					}
				}
				return { success: 200 };
			}
		</script>

		<script>
			import { getContext } from 'svelte';

			export let localizedPaths;

			const i18n = getContext('__svelte_i18n__');
			i18n.update((i18n) => ({
				...i18n,
				localizedPaths
			}));
		</script>

		<svelte:head>
			<link rel="alternate" hreflang="x-default" href="{localizedPaths[$i18n.defaultLocale]}" />
			{#each $i18n.locales as locale}
				<link rel="alternate" hreflang="{locale.iso}" href="{localizedPaths[locale.code]}" />
			{/each}
		</svelte:head>

		<slot></slot>
		`
			.replace(/^\t\t/gm, '')
			.trim();

		mkdirp(path.dirname(file));
		fs.writeFileSync(file, code);

		return path.relative(cwd, file);
	}

	function create_redirect_component() {
		const dir = `${output}/components`;
		const file = `${dir}/redirect.svelte`;
		const { defaultLocale, locales } = config.kit.i18n || {};
		const code = `
		<!-- This file is generated by @sveltejs/kit — do not edit it! -->
		<script>
			import { browser } from '../runtime/app/env';
			import { i18n, page } from '../runtime/app/stores';

			if (browser) {
				const cookieLocale = document.cookie
					.split(/;\\s*/)
					.find((c) => c.startsWith('locale='))
					?.split('=')[1];

				const locale =
					$i18n.locales.find(({ iso }) => iso.toLowerCase() === cookieLocale?.toLowerCase()) ||
					$i18n.locales.find(({ iso }) => iso.toLowerCase() === navigator.language.toLowerCase()) ||
					$i18n.locales.find(
						({ iso }) => iso.split(/[_-]/)[0] === navigator.language.split(/[_-]/)[0]
					) ||
					$i18n.locales.find(({ code }) => code === $i18n.defaultLocale) ||
					$i18n.locales[0];

				if (!$page.path.startsWith(\`/\${locale.code}/\`)) {
					location.replace(\`/\${locale.code}\${$page.path}\`);
				}
			}
		</script>
		${
			locales
				? `
		<svelte:head>
			{#if $page.path === "/"}
			<link rel="alternate" hreflang="x-default" href="/${
				locales.find((l) => l.code === defaultLocale).prefix || ''
			}" />
			${locales
				.map((l) => `<link rel="alternate" hreflang="${l.iso}" href="/${l.prefix || ''}" />`)
				.join('\n\t')}
			{/if}
		</svelte:head>`
				: ''
		}
		`
			.replace(/^\t\t/gm, '')
			.trim();

		mkdirp(path.dirname(file));
		fs.writeFileSync(file, code);

		return path.relative(cwd, file);
	}

	/**
	 * @param {Part[][]} segments
	 * @param {import('types/i18n').I18nLocale} locale
	 * @returns {Part[][]}
	 */
	function get_prefixed_segments(segments, locale) {
		if (locale.prefix) {
			return [[{ content: locale.prefix, dynamic: false, spread: false }], ...segments];
		}
		return segments;
	}

	/**
	 * @param {Part[][]} segments
	 * @param {import('types/i18n').I18nLocale} locale
	 * @param {Translations[]} translations
	 * @returns {Part[][]}
	 */
	function get_translated_segments(segments, locale, translations) {
		if (translations.length === 0) return get_prefixed_segments(segments, locale);

		return get_prefixed_segments(
			segments.map((parts) =>
				parts.map((part) => {
					if (part.dynamic) return part;

					for (let i = translations.length - 1; i >= 0; i--) {
						const localeTranslations = translations[i][locale.code];
						if (!isTranslations(localeTranslations)) continue;

						const tr = localeTranslations['_routes'];
						if (tr && typeof tr !== 'string' && tr[part.content]) {
							const translation = tr[part.content];
							if (typeof translation === 'string') return { ...part, content: translation };
						}
					}
					return part;
				})
			),
			locale
		);
	}

	/** @type {string[]} */
	const components = [];

	/** @type {{[locale: string]: string}} */
	const locale_components = {};

	/** @type {import('types/internal').RouteData[]} */
	const routes = [];

	const default_layout = posixify(path.relative(cwd, `${output}/components/layout.svelte`));
	const default_error = posixify(path.relative(cwd, `${output}/components/error.svelte`));
	const locale_redirect = config.kit.i18n && create_redirect_component();

	const translations =
		(config.kit.i18n &&
			find_translations(undefined, path.relative(cwd, config.kit.files.translations))) ||
		{};

	if (config.kit.i18n) {
		const { locales } = config.kit.i18n;

		if (locales.length > 0 && !locales.find((l) => l.prefix === undefined || l.prefix === null)) {
			components.push(locale_redirect);
		}

		locales.forEach((locale) => {
			const component = create_locale_component(locale, toTranslations(translations[locale.code]));
			locale_components[locale.code] = component;
			components.push(component);
		});
	}

	/**
	 * @param {string} dir
	 * @param {Part[][]} parent_segments
	 * @param {string[]} parent_params
	 * @param {string[]} layout_stack // accumulated $layout.svelte components
	 * @param {string[]} error_stack // accumulated $error.svelte components
	 * @param {Translations[]} translations_stack
	 */
	function walk(
		dir,
		parent_segments,
		parent_params,
		layout_stack,
		error_stack,
		translations_stack
	) {
		/** @type {Item[]} */
		const items = fs
			.readdirSync(dir)
			.map((basename) => {
				const resolved = path.join(dir, basename);
				const file = posixify(path.relative(cwd, resolved));
				const is_dir = fs.statSync(resolved).isDirectory();

				const ext =
					config.extensions.find((ext) => basename.endsWith(ext)) || path.extname(basename);

				if (basename[0] === '$') return null; // $layout, $error
				if (basename[0] === '_') return null; // private files
				if (basename[0] === '.' && basename !== '.well-known') return null;
				if (!is_dir && !/^(\.[a-z0-9]+)+$/i.test(ext)) return null; // filter out tmp files etc

				const segment = is_dir ? basename : basename.slice(0, -ext.length);

				if (/\]\[/.test(segment)) {
					throw new Error(`Invalid route ${file} — parameters must be separated`);
				}

				if (count_occurrences('[', segment) !== count_occurrences(']', segment)) {
					throw new Error(`Invalid route ${file} — brackets are unbalanced`);
				}

				if (/.+\[\.\.\.[^\]]+\]/.test(segment) || /\[\.\.\.[^\]]+\].+/.test(segment)) {
					throw new Error(`Invalid route ${file} — rest parameter must be a standalone segment`);
				}

				const parts = get_parts(segment, file);
				const is_index = is_dir ? false : basename.startsWith('index.');
				const is_page = config.extensions.indexOf(ext) !== -1;
				const route_suffix = basename.slice(basename.indexOf('.'), -ext.length);

				return {
					basename,
					ext,
					parts,
					file: posixify(file),
					is_dir,
					is_index,
					is_page,
					route_suffix
				};
			})
			.filter(Boolean)
			.sort(comparator);

		items.forEach((item) => {
			const segments = parent_segments.slice();

			if (item.is_index) {
				if (item.route_suffix) {
					if (segments.length > 0) {
						const last_segment = segments[segments.length - 1].slice();
						const last_part = last_segment[last_segment.length - 1];

						if (last_part.dynamic) {
							last_segment.push({
								dynamic: false,
								spread: false,
								content: item.route_suffix
							});
						} else {
							last_segment[last_segment.length - 1] = {
								dynamic: false,
								spread: false,
								content: `${last_part.content}${item.route_suffix}`
							};
						}

						segments[segments.length - 1] = last_segment;
					} else {
						segments.push(item.parts);
					}
				}
			} else {
				segments.push(item.parts);
			}

			const params = parent_params.slice();
			params.push(...item.parts.filter((p) => p.dynamic).map((p) => p.content));

			if (item.is_dir) {
				const layout_reset = find_layout('$layout.reset', item.file);
				const layout = find_layout('$layout', item.file);
				const error = find_layout('$error', item.file);
				const translations = find_translations('$translations', item.file);

				if (layout_reset && layout) {
					throw new Error(`Cannot have $layout next to $layout.reset: ${layout_reset}`);
				}

				if (layout_reset) components.push(layout_reset);
				if (layout) components.push(layout);
				if (error) components.push(error);

				walk(
					path.join(dir, item.basename),
					segments,
					params,
					layout_reset ? [layout_reset] : layout_stack.concat(layout),
					layout_reset ? [error] : error_stack.concat(error),
					translations ? translations_stack.concat(translations) : translations_stack
				);
			} else if (item.is_page) {
				components.push(item.file);

				const pages = [];

				if (config.kit.i18n?.locales.length > 0) {
					const patterns = config.kit.i18n.locales.map((locale) => ({
						locale: locale.code,
						pattern: get_pattern(
							get_translated_segments(segments, locale, translations_stack),
							true
						)
					}));

					/** @type {string | undefined} */
					const patternComponent = create_pattern_component(item.file, patterns);
					components.push(patternComponent);

					patterns.forEach(({ locale, pattern }) => {
						pages.push({
							pattern,
							layout: [locale_components[locale], ...layout_stack, patternComponent, item.file]
						});
					});

					if (!config.kit.i18n.locales.find((l) => !l.prefix)) {
						pages.push({ pattern: get_pattern(segments, true), layout: [locale_redirect] });
					}
				} else {
					pages.push({
						pattern: get_pattern(segments, true),
						layout: [...layout_stack, item.file]
					});
				}

				pages.forEach(({ pattern, layout }) => {
					const a = layout;
					const b = error_stack;

					let i = a.length;
					while (i--) {
						if (!b[i] && !a[i]) {
							b.splice(i, 1);
							a.splice(i, 1);
						}
					}

					i = b.length;
					while (i--) {
						if (b[i]) break;
					}

					b.splice(i + 1);

					const path = segments.every((segment) => segment.length === 1 && !segment[0].dynamic)
						? `/${segments.map((segment) => segment[0].content).join('/')}`
						: null;

					routes.push({
						type: 'page',
						pattern,
						params,
						path,
						a,
						b
					});
				});
			} else {
				const pattern = get_pattern(segments, !item.route_suffix);

				routes.push({
					type: 'endpoint',
					pattern,
					file: item.file,
					params
				});
			}
		});
	}

	const base = path.relative(cwd, config.kit.files.routes);

	const layout = find_layout('$layout', base) || default_layout;
	const error = find_layout('$error', base) || default_error;

	components.push(layout, error);

	walk(config.kit.files.routes, [], [], [layout], [error], [translations]);

	const assets_dir = config.kit.files.assets;

	return {
		assets: fs.existsSync(assets_dir) ? list_files(assets_dir, '') : [],
		layout,
		error,
		components,
		routes,
		i18n: config.kit.i18n
	};
}

/**
 * @param {string} needle
 * @param {string} haystack
 */
function count_occurrences(needle, haystack) {
	let count = 0;
	for (let i = 0; i < haystack.length; i += 1) {
		if (haystack[i] === needle) count += 1;
	}
	return count;
}

/** @param {string} path */
function is_spread(path) {
	const spread_pattern = /\[\.{3}/g;
	return spread_pattern.test(path);
}

/**
 * @param {Item} a
 * @param {Item} b
 */
function comparator(a, b) {
	if (a.is_index !== b.is_index) {
		if (a.is_index) return is_spread(a.file) ? 1 : -1;

		return is_spread(b.file) ? -1 : 1;
	}

	const max = Math.max(a.parts.length, b.parts.length);

	for (let i = 0; i < max; i += 1) {
		const a_sub_part = a.parts[i];
		const b_sub_part = b.parts[i];

		if (!a_sub_part) return 1; // b is more specific, so goes first
		if (!b_sub_part) return -1;

		// if spread && index, order later
		if (a_sub_part.spread && b_sub_part.spread) {
			return a.is_index ? 1 : -1;
		}

		// If one is ...spread order it later
		if (a_sub_part.spread !== b_sub_part.spread) return a_sub_part.spread ? 1 : -1;

		if (a_sub_part.dynamic !== b_sub_part.dynamic) {
			return a_sub_part.dynamic ? 1 : -1;
		}

		if (!a_sub_part.dynamic && a_sub_part.content !== b_sub_part.content) {
			return (
				b_sub_part.content.length - a_sub_part.content.length ||
				(a_sub_part.content < b_sub_part.content ? -1 : 1)
			);
		}
	}

	if (a.is_page !== b.is_page) {
		return a.is_page ? 1 : -1;
	}

	// otherwise sort alphabetically
	return a.file < b.file ? -1 : 1;
}

/**
 * @param {string} part
 * @param {string} file
 */
function get_parts(part, file) {
	return part
		.split(/\[(.+?\(.+?\)|.+?)\]/)
		.map((str, i) => {
			if (!str) return null;
			const dynamic = i % 2 === 1;

			const [, content] = dynamic ? /([^(]+)$/.exec(str) : [null, str];

			if (dynamic && !/^(\.\.\.)?[a-zA-Z0-9_$]+$/.test(content)) {
				throw new Error(`Invalid route ${file} — parameter name must match /^[a-zA-Z0-9_$]+$/`);
			}

			return {
				content,
				dynamic,
				spread: dynamic && /^\.{3}.+$/.test(content)
			};
		})
		.filter(Boolean);
}

/**
 * @param {Part[][]} segments
 * @param {boolean} add_trailing_slash
 */
function get_pattern(segments, add_trailing_slash) {
	const path = segments
		.map((segment) => {
			return segment[0].spread
				? '\\/?(.*)'
				: '\\/' +
						segment
							.map((part) => {
								return part.dynamic
									? '([^/]+?)'
									: encodeURI(part.content.normalize())
											.replace(/\?/g, '%3F')
											.replace(/#/g, '%23')
											.replace(/%5B/g, '[')
											.replace(/%5D/g, ']')
											.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
							})
							.join('');
		})
		.join('');

	const trailing = add_trailing_slash && segments.length ? '\\/?$' : '$';

	return new RegExp(`^${path || '\\/'}${trailing}`);
}

/**
 * @param {string} dir
 * @param {string} path
 * @param {import('types/internal').Asset[]} files
 */
function list_files(dir, path, files = []) {
	fs.readdirSync(dir).forEach((file) => {
		const full = `${dir}/${file}`;

		const stats = fs.statSync(full);
		const joined = path ? `${path}/${file}` : file;

		if (stats.isDirectory()) {
			list_files(full, joined, files);
		} else {
			if (file === '.DS_Store') return;
			files.push({
				file: joined,
				size: stats.size,
				type: mime.getType(joined)
			});
		}
	});

	return files;
}
